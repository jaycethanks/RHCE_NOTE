[TOC]

> 特别注意:warning: 本章内容相比原文有很多细节上的删减，目的是了解大概的情况。 需要掌握本章内容，需要实践操作一边。
>
> 此外，找时间找个教程视频看看，看看别人是怎么整理着部分内容的。  管理文件系统相比Windows是比较麻烦的，要求更加的清楚内部过程原理。







### 8.1 Linux 文件系统

Linux支持多种类型的文件系统管理文件和目录。 每种文件系统都在存储设备上实现了虚拟目录结构。 

不同文件系统之间仅特性略有不同。 有必要了解Linux 环境下较为常用的文件系统的优缺点。



#### 8.1.1 基本Linux 文件系统



##### 1.ext 文件系统

| 文件系统名                               | 简介                                                         | 特点                                                         | 存在问题                                                    |
| :--------------------------------------- | :----------------------------------------------------------- | ------------------------------------------------------------ | ----------------------------------------------------------- |
| ext（扩展文件系统，extended filesystem） | 这是Linux 操作系统中引入最早的文件系统，名为**扩展文件系统**（extended filesystem, ext）。 | 采用了名为**索引节点**的系统来存放虚拟目录中所存储文件的信息。 索引节点系统在每个物理设备中创建了一个单独的表（索引节点表）来存储这些文件的信息。 存储在虚拟目录中的每个文件在索引节点表中对应的条目。 ext 文件系统名称中的 extended部分来自其跟中的每个文件的额外数据。 包括：<br />-文件名 <br />-文件大小 <br />-文件的属主 <br />-文件的属组 <br />-文件的访问权限 <br />-指向存有文件数据的每个硬盘块的指针 | 最早的ext文件系统有不少的限制， 比如，文件大小不得超过2GB。 |



##### 2.ext2 文件系统

| 文件系统名        | 简介                                                         | 特点                                                         | 存在问题                                                     |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ext2（ext的升级） | ext2 文件系统扩展了索引节点表的格式来保存系统上每个文件的更多信息。 | - 支持文件大小扩展到32TB<br />- 改变了文件在数据块中存储的方式。 ext文件系统常见的问题是在文件写入到物理设备的时候。 存储数据用的块很容易分散在整个设备中。 （称作碎片化fragmentation）。 数据块的碎片化会降低文件系统的性能。 因为需要更长的时间在存储设备中查找特定文件的所有块。 | ext文件系统，文件系统每次存储或者更新文件，它都需要用新信息来更新索引节点列表。 如果计算机系统在存储文件和更新索引节点列表之间出现问题，二者内容就不同步了。<br />ext文件系统由于容易在系统崩溃或者断电时损坏 |



#### 8.1.2 日志文件系统

日志文件系统为Linux 系统增加了一层安全性。 它不再是将数据直接写入存储设备再更新索引节点表，而是先将文件的更改写入到临时文件（称作日志，journal）中。再数据成功写到存储设备和索引节点表之后，在删除对应的日志条目。

如果系统在数据被写入成功之前因崩溃或断电而中断，日志文件系统下次会读取日志文件并处理上次留下的未写入的数据。

Linux 中有三种广泛使用日志的方法，每种的保护登录都不相同。

| 方法                  | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| <mark>数据</mark>模式 | 索引节点和文件都会被写入日志，丢失数据风险低，但是性能差。   |
| <mark>有序</mark>模式 | 只有索引节点数据会被写入日志，但是只有数据成功写入之后才会被删除，在性能和安全性之间取得了一个良好的折中 |
| <mark>回写</mark>模式 | 只有索引节点数据会被写入日志，但不控制文件数据何时写入，丢失数据风险高，但任比不用日志好 |

##### 1. ext3 文件系统（2001年）

| 文件系统名         | 简介                                                         | 特点               | 存在问题                                                     |
| ------------------ | ------------------------------------------------------------ | :----------------- | ------------------------------------------------------------ |
| ext3（ext2的升级） | 和ext2 采用相同的索引节点表结构，但是给每个存储设备增加了一个日志文件，以将准备写入存储设备的数据先接入日志。 | 添加了基本日志功能 | ext3 虽然添加了基本日志功能，但是无法恢复误删除的文件，没有任何内建的数据压缩功能，也不支持文件加密。 |



> 你可以在创建文件系统的时候用简单的一个命令行选项将ext3文件系统的日志方法改成数据模式或者回写模式



##### 2. ext4 文件系统（2008年）

| 文件系统名         | 简介                                                         | 特点                                                         | 存在问题 |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| ext4（ext3的升级） | ext4文件系统在2008年受到Linux内核官方支持，现在是大多数流行的Linux发行版采用的默认文件系统，比如Ubuntu。 | - 支持数据加密和压缩<br />- 还支持一个称作区段（extent) 的特性。 区段在存储设备上按块分配空间，但在索引节点表中只保存其实块的位置。<br />- 引入了**块预分配技术**（block preallocation）。 如果你想在存储设备上给一个你知道要变大的文件预留空间，ext4文件系统可以为文件分配所有需要用到的块。而不仅仅是那些现在已经用到的块。 ext4文件系统用0填满预留的数据块，不会将它们分配给其他文件。 |          |



##### 3. Reiser 文件系统（2001）

| 文件系统名     | 简介                                                         | 特点                                                         | 存在问题 |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| Reiser文件系统 | 第一个称为ReiserFS的日志文件系统。只支持回写日志模式 （只把索引节点表数据写入到日志文件。）也因此成为Linux上最快的日志文件系统之一。 | -可以在线调整已有文件系统的大小；<br />- 尾部压缩技术（tailpacking），将一个文件的数据填进另一个文件的数据块中的而空白空间。 |          |

> 如果你必须为已有文件系统扩容来容纳更多的数据，在线调整文件系统大小功能非常好用。

##### 4. JFS 文件系统（1990）

| 文件系统名                 | 简介                               | 特点                                                         | 存在问题                 |
| -------------------------- | ---------------------------------- | ------------------------------------------------------------ | ------------------------ |
| JFS（Journal File System） | 可能是再用的最老的日志文件系统之一 | - 采用有序日志方法（只在日志中保存索引节点表数据，直到真正的文件数据呗写入到存储设备是才删除）<br />- 采用基于区段的文件分配，即为每个写入存储设备的文件分配一组块。这样可以减少存储设备上的随票。 | 除了IBM   Linux， 用的少 |

##### 5. XFS 文件系统（1994）

| 文件系统名 | 简介                                                   | 特点                                                         | 存在问题 |
| ---------- | ------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| XFS（）    | 另一种最初商用于Unix 的文件系统，2002年被发布到了Linux | - 采用回写模式的日志，在提高了高性能的同时，也引入了一定风险。因为实际数据并未存进日志文件。<br />- 允许在线调整文件系统的大小，类似ReiserFS，但只能扩大不能缩小 |          |

#### 8.1.3 写时复制文件系统

采用了日志文件系统，就必须在安全稳定和性能之间做出权衡选择。

数据模式日志提供了最高的安全稳定性，但是会因为索引节点和数据都需要被日志化而对性能回带来影响。

回写模式，性能可以介绍，安全稳定性就会差一些。



就文件系统而言，日志的另一种选择，叫做**写时复制（copy-on-write,COW）**的技术。COW 利用**快照** 兼顾了安全性和性能。如果要修改数据，会使用克隆或者可写快照。修改过的数据并不会直接覆盖当前的数据，而是被放入文件系统中的另一个位置上。 即是是数据修改已经完成，之前的就数据也不会被重写。

COW文件系统中，最流行的是Btrf 和 ZFS



##### 1.ZFS 文件系统（2005）

| 文件系统名  | 简介                                                         | 特点                           | 存在问题                                       |
| ----------- | ------------------------------------------------------------ | ------------------------------ | ---------------------------------------------- |
| ZFS文件系统 | Sun公司开发，起初用于OpenSolaris系统，2012投入Linux，ZFS 是一个稳定的文件系统。 | 和Resier4、Btrfs、ext4势均力敌 | 没有使用GPL许可，所以无法成为Linux默认文件系统 |

> GPL（*GPL*，是GNU General Public License的缩写，是GNU通用公共许可证）

##### 2.Btrf 文件系统（2007）

| 文件系统名   | 简介                                                         | 特点                                                         | 存在问题 |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| Btrf文件系统 | COW的新人，也成B树文件系统，Oracle开发。 <br />OpenSUSE Linux 发行版将Btrf作为其默认文件系统。 红帽也出现了，不过不是作为默认问文件系统。 | - 在Reiser4 的诸多特性的基础上改进了可靠性。<br />- 稳定、易用、能够动态调整已挂载文件系统的大小 |          |



### 8.2 操作文件系统



#### 8.2.1 创建分区



一开始，你必须在存储设备上创建分区来容纳文件系统。 分区可以是整个硬盘，也可以是分硬盘。以容纳虚拟目录的一部分。

fdisk 工具用来帮助管理安装在系统上的任何存储设备上的而分区。它是个交互式程序，逐步完成硬盘分区操作。

启动fdisk，必须指定

**要分区的存储设备的设备名以及超级用户权限**

> 		Linux中，物理磁盘的挂载名有以下规则：
>
> 	- 对于老式的IDE驱动器，Linux使用的是/dev/hdx 。
> 	- SATA 和 SCSI ，Linux 使用/dev/sdx 
>
> 	*( x为一个字母，表示了驱动器被检测的顺序，第一个驱动器是a,第二个是b...)*

```bash
##root身份
fdisk /dev/sdb
```

如果是第一次给该存储设备分区，fdisk会警告你设备上没有分区表。



**`fdisk` 命令**

| 命令 | 描述                             |
| ---- | -------------------------------- |
| a    | 设置活动分区标志                 |
| b    | 编辑BSD Unix系统用的磁盘标签     |
| c    | 设置DOS兼容标志                  |
| d    | 删除分区                         |
| l    | 显示可用的分区类型               |
| m    | 显示命令选项                     |
| n    | 添加一个新分区                   |
| o    | 创建DOS分区表                    |
| p    | 显示当前分区表                   |
| q    | 退出，保存更改                   |
| s    | 为Sun Unix系统创建一个新磁盘标签 |
| t    | 修改分区的系统ID                 |
| u    | 改变使用的存储单位               |
| v    | 验证分区表                       |
| w    | 将分区表写入磁盘                 |
| x    | 高级功能                         |



如果需要 查看设备的详细信息，可以使用 `p` 命令：

```bash
[root@localhost dev]# fdisk /dev/sda

Welcome to fdisk (util-linux 2.32.1).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.


Command (m for help): p
Disk /dev/sda: 931.5 GiB, 1000204886016 bytes, 1953525168 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 4096 bytes
I/O size (minimum/optimal): 4096 bytes / 4096 bytes
Disklabel type: gpt
Disk identifier: 41804238-9AC5-42F3-A9AF-CCC6A44C9A3D

Device       Start        End    Sectors   Size Type
/dev/sda1     2048    1230847    1228800   600M EFI System
/dev/sda2  1230848    3327999    2097152     1G Linux filesystem
/dev/sda3  3328000 1953523711 1950195712 929.9G Linux LVM
```



具体的分区步骤（略）



输出中可以看到，已有 sda1, sda2, sda3 三个分区。最后的Type字段即是分区类型。 如果需要查看更多的分区类型，可以使用`l`命令：

```bash
Command (m for help): l
  1 EFI System                     C12A7328-F81F-11D2-BA4B-00A0C93EC93B
  2 MBR partition scheme           024DEE41-33E7-11D3-9D69-0008C781F39F
  3 Intel Fast Flash               D3BFE2DE-3DAF-11DF-BA40-E3A556D89593
  4 BIOS boot                      21686148-6449-6E6F-744E-656564454649
  5 Sony boot partition            F4019732-066E-4E12-8273-346C5641494F
  6 Lenovo boot partition          BFBFAFE7-A34F-448A-9A5B-6213EB736C22
  7 PowerPC PReP boot              9E1A2D38-C612-4316-AA26-8B49521E5A8B
  8 ONIE boot                      7412F7D5-A156-4B13-81DC-867174929325
  9 ONIE config                    D4E6E2CD-4469-46F3-B5CB-1BFF57AFC149
 10 Microsoft reserved             E3C9E316-0B5C-4DB8-817D-F92DF00215AE
 11 Microsoft basic data           EBD0A0A2-B9E5-4433-87C0-68B6B72699C7
 .
 .
 .
```



#### 8.2.2 创建文件系统

**格式化**

在将数据存储到分区之前，你必须 用某种文件系统对其进行格式化。这样Linux才能开始使用它。

每种文件系统类型都用自己的命令程序来格式化分区。 以下是不同文件系统所对应的工具。

| 工具       | 用途                     |
| ---------- | ------------------------ |
| mkefs      | 创建一个ext文件系统      |
| mke2fs     | 创建一个ext2文件系统     |
| mkfs.ext3  | 创建一个ext3文件系统     |
| mkfs.ext4  | 创建一个ext4文件系统     |
| mkreiserfs | 创建一个ReiserFS文件系统 |
| jfs_mkfs   | 创建一个JFS文件系统      |
| mkfs.xfs   | 创建一个XFS文件系统      |
| mkfs.zfs   | 创建一个ZFS文件系统      |
| mkfs.btrfs | 创建一个Btrfs文件系统    |

并非所有文件系统工具都已经默认安装了。 如果需要知道某文件系统工具是否可用，可以使用`type` 命令

```bash
[root@localhost dev]# type mkfs.ext4
mkfs.ext4 is /usr/sbin/mkfs.ext4
[root@localhost dev]# type mkfs.btrfs
-bash: type: mkfs.btrfs: not found
```

而每一个文件系统命令都有很多命令行选项，可以查看对应的man手册。

但是所有的文件系统命令都允许通过不带任何选项的简单命令来创建一个默认的文件系统。

```bash
sudo mkfs.ext4 /dev/sdb1
```

在为分区创建了文件系统之后，下一步是将它们挂在到虚拟目录下的某个挂载点，这样就可以将数据存储在新文件系统中了。

你可以将新的文件系统挂载到虚拟目录中需要额外空间的任何位置。

```bash
$ ls /mnt
$
$ sudo mkdir /mnt/my_partition
$
$ ls -al /mnt/my_partition/
$
$ ls -dF /mnt/my_partition
/mnt/my_partition/
$
$ sudo mount -t ext4 /dev/sdb1
$
$ ls -al /mnt/my_partition/
total 24
drwxr-xr-x. 3 root root 4096 Jun
drwxr-xr-x. 3 root root 4096 Jun
drwx------. 2 root root 16384 Jun
$
```

mkdir命令在虚拟目录中创建了挂载点，mount命令将新的硬盘分区添加到挂载点。 mount命令的`-t`选项指明了要挂载的文件系统类型（ext4）。现在你可以在新分区中保存新文件和目录了。

> 这种挂载文件系统的方法只能临时挂载文件系统。当重启Linux系统的时候，文件系统并不会自动挂载。要强制Linux在启动时自动挂载新的文件系统，可以 将其添加到/etc/fstab文件。



#### 8.2.3 文件系统的检查与修复

突然断电，或者程序运行导致的访问文件时锁定了系统，也会出现错误。

一些命令行工具可以帮助你将文件系统恢复正常。

每个文件系统都有各自和文件系统交互的恢复命令。随着Linux环境中可用的文件系统便多，你也不得不去掌握大量对应的命令。好在有个通用的前端程序，可以决定存储设备上的文件系统并根据要恢复的文件系统调用适合的文件系统恢复命令。

`fsck`命令能够检查和修复大部分类型的Linux文件系统，包括了本章节提到的各种文件系统。该命令的格式是：

```bash
fsck options filesystem
```

你可以在命令行上列出多个要 检查的文件系统。文件系统还可以通过设备名、在虚拟目录中的挂载 点以及分配给文件系统的唯一UUID值来引用。

> 尽管日志式文件系统的用户需要用到fsck 命令。但是COW文件系统的用户是否也得使用该命令还存在争议。

`fsck`命令使用/etc/fstab 文件来自动决定正常挂载到系统上的存储设备的文件系统。如果存储设备尚未挂载（比如你刚刚在新的存储设备上创建了一个文件系统）。你需要用`-t`命令行选项来指定文件系统类型

**fsck命令行选项**

| 选项 | 描述                                                       |
| ---- | ---------------------------------------------------------- |
| -a   | 如果检测到错误，自动修复文件系统                           |
| -A   | 检查/etc/fstab/文件中列出的所有文件系统                    |
| -C   | 给支持进度条功能的文件系统显示一个进度条（只有ext2和ext3） |
| -N   | 不进行检查，值显示那些 检查会执行                          |
| -r   | 出现错误时提示                                             |
| -R   | 使用-A选项时条跳过根文件系统                               |
| -s   | 检查多个文件系统时，依次进行检查                           |
| -t   | 指定要检索的文件系统类型                                   |
| -T   | 启动时不显示头部信息                                       |
| -V   | 在检查时产生 详细输出                                      |
| -y   | 检测到错误时自动修读文件系统                               |

有些命令选项是重复的，这是为了多个命令实现通用的前端带来的部分问题。 有些文件系统修复命令有一些额外的可用选项。如果要做更高级的错误检查，就需要查看这个文件系统修复工具的手册页来确定是不是有 该文件系统专用的扩展选项。

> 只能在未挂载的文件系统上运行fsck命令。对大多数文件系统来说，你只需要卸载文件系统来进行检查，检查完了之后重新挂载就好了。
>
> 但是因为根文件系统含所有核心的Linux命令和日志文件，所以 你无法在处于运行状态的系统上卸载它。
>
> 可以通过LiveCD 启动系统，然后在根文件系统上运行fsck命令。

### 8.3 逻辑卷管理

如果用标准分区在硬盘上创建了文件系统，为已有文件系统添加额外的空间多少是一种痛苦的体验。你只能在同一个物理硬盘的可用空间范围内调整分区大小。如果硬盘上没有地方了，你必须弄一个更大的硬盘，然后手动将已有的文件系统移动到新的硬盘。

这时候，可以通过将另一个硬盘上 的 分区加入已有文件系统，动态地添加存储空间。Linux逻辑卷管理器（logical volume manager,LVM）软件包正好可以用来做这个。它可以让你i在无需重建整个文件系统的情况下，轻松地管理磁盘空间。



#### 8.3.1 逻辑卷管理布局

逻辑卷管理的核心在于如何处理安装在系统上硬盘分区。在逻辑卷管理的世界里，硬盘称作物理卷（physical volume，PV）。每个物理卷都会映射到硬盘上特定的物理分区。

多个物理卷集中在一起可以形成一个卷组（volume group ,VG）。逻辑卷管理系统将卷组<mark>视为一个物理硬盘</mark>，但事实上卷组可能是由分布在多个物理硬盘上的多个物理分区组成。 圈足提供了一个创建逻辑分区的平台，而这些逻辑分区则包含了文件系统。

整个结构中的最后一层时逻辑卷（logical volume，LV）。逻辑卷为Linux提供了创建文件系统的分区环境，作用类似与目前为止我们一直在探讨的Linux

中的物理硬盘分区。Linux系统将逻辑卷视为物理分区。

可以使用任何一种标准Linux文件系统来格式化逻辑卷，然后再将它加入Linux虚拟目录中的某个挂载点。



![image-20201013074858736](第八章 管理文件系统.assets/image-20201013074858736.png)



（图8-1 逻辑卷管理环境）

图中的卷组横跨了三个不同的物理硬盘，覆盖了五个独立的物理分区。在卷组内部有两个独立逻辑卷。

类似地如果你给系统添加了一块硬盘，逻辑卷管理系统允许你将它添加到已有卷组，为某个已有卷组创建更多空间。或是创建一个可用来挂载的新逻辑卷。



#### 8.3.2 Linux 中的LVM

Linux LVM 允许你在Linux上用简单的命令行管理一个完整的逻辑卷管理环境。

Linux LVM 有两个可用的版本：

- LVM1 ：只能用于Linux 内核2.4 ，仅提供了基本的逻辑卷管理功能。
- LVM2： LVM的更新版本，可用于Linux内核2.6 版本。它在标准的LVM功能外提供了额外的功能。

大部分采用2.6 或更高版本内核的现代Linux发行版都提供对LVM2 的支持。 除了标准的逻辑卷管理功能外，LVM2还提供了 另外一些好用的功能。

> ##查看Linux版本
>
> jayce@DESKTOP-JASQLDM:~$ cat /proc/version
> Linux version 4.19.128-microsoft-standard (oe-user@oe-host) (gcc version 8.2.0 (GCC)) #1 SMP Tue Jun 23 12:58:10 UTC 2020

##### 1.快照

最初的Linux LVM 允许你在逻辑卷在线的状态下将其复制到另一个设备。这个功能叫做快照。 在备份由于高可靠性需求而无法锁定的重要数据时，快照功能非常给力。传统的备份方法在将文件复制到备份媒体上时通常要将文件锁定。快照 允许你在复制的同时，保存运行关键任务Web服务器或数据库服务器继续工作。但是LVM1只允许你创建只读快照。一旦创建可快照，就不能在写入东西了。

LVM2允许你创建在线逻辑卷的可读写快照。 有了可读写的快照，就可以删除原先的逻辑卷，然后将快照作为替代挂载上。 这个功能对快速故障转移或者涉及修改数据程序试验（如果失败，需要恢复修改过的数据）非常有用。

##### 2. 条带化

LVM2 提供的另一个引人注目的功能是条带化（striping）。有了条带化，可跨多个物理硬盘创建逻辑卷。当Linux LVM将文件写入逻辑卷时，文件中的数据块会被分散到多个硬盘上。每个后继数据块会被写道下一个硬盘上。

条带化有助于提高硬盘的性能，因为Linux可以将一个文件的多个数据块 同时写入多个硬盘，而无需等待单个硬盘 移动读写磁头到多个不同位置。 这个改进同样适用于读取顺序访问的文件。因为LVM可同时从多个硬盘读取数据。

> LVM 条带化不同于RAID条带化。LVM条带化不提供用来创建容错环境的校验信息。事实上，LVM 条带化会增加文件因硬盘故障而丢失的概率。单个硬盘可能会造成多个逻辑卷无法访问。

##### 3.镜像

通过LVM 安装文件系统并意味着文件系统就不会再出现问题。 和物理分区一样，LVM 逻辑卷也容易受断点和磁盘故障的影响。一旦文件系统损坏，就有可能再也无法恢复。

LVM快照功能提供了一些安慰，你可以岁时创建逻辑卷的备份副本，但是对有些环境来说可能还不够。 对于设计大量数据变动的系统，比如数据库服务器，自上次快照之后可能要存储成百上千条记录。

这个问题的一个解决办法就是LVM 镜像。镜像是一个实时更新的逻辑卷的完整副本。当你创建镜像逻辑卷时，LVM会将原始逻辑卷同步到镜像副本中。 根据原始逻辑卷的大小，这可能需要一些时间才能完成。

一旦原始同步完成，LVM会为文件系统的每次写操作执行两次写入。一次写入到主逻辑卷，一次写入到镜像副本。可以想象，这个过程会降低系统的写入性能。 就算原始逻辑卷因为某些原因损坏了，你手头也已经有了一个完整的最新副本。

#### 8.3.3 使用Linux LVM

##### 1.定义物理卷

创建过程的第一步是将硬盘上的物理分区转换成Linux LVM 使用的物理卷区段， fdisk命令可以帮忙。在创建了基本的Linux分区之后，需要通过`t` 命令改变分区类型。



用分区来创建实际的物理卷，可以通过`pvcreate` 命令来完成。pvcreate定义了用于物理卷的物理分区。 它只是简单地将分区标记成Linux LVM系统中的分区而已。

```bash
sudo pvcreate /dev/sdb1
```

如果要查看创建进度，可以使用`pvdisplay` 命令

```bash
sudo pvdisplay /dev/sdb1
```

##### 2.创建卷组

从物理卷中创建一个或者多个卷组。使用vgcreate 命令。

该命令需要一些命令行参数来定义卷组名以及你用来创建卷组的物理卷名。

```bash
sudo vgcreate Vol1 /dev/sdb1
```

通过`vgdisplay`命令可以查看更多细节

```bash
sudo vgdisplay Vol1
```

##### 3.创建逻辑卷

Linux系统使用逻辑卷来模拟物理分区，并在其中保存文件系统。Linux系统会像处理分区一样处理逻辑卷，允许你定义逻辑卷中的文件系统，然后将文件系统挂载到虚拟目录上。

创建逻辑卷，使用`lvcreate`命令。

该命令支持很多参数，附表（略），自行查看手册。

##### 4. 创建文件系统

逻辑卷创建完，还没有文件系统，必须使用相应的命令行程序来创建所需要的文件系统。

```bash
sudo mkfs.ext4 /dev/Vol1/lvtest
```

在创建了新的文件系统之后，可以用标准Linux mount命令将这个卷挂载到虚拟目录中，就跟它是物理分区一样。唯一的不同时你需要用特殊的路径来标识逻辑卷。

```bash
sudo mount /dev/Vol1/lvtest /mnt/my_partition
```

##### 5. 修改LVM 

Linux LVM的好处在于能够动态的修改文件系统。以下时一些常见的命令：

| 命令     | 功能                 |
| -------- | -------------------- |
| vgchange | 激活和禁用卷组       |
| vgremove | 删除卷组             |
| vgextend | 将物理卷加入到卷组中 |
| vgreduce | 从卷组中删除物理卷   |
| lvextend | 增减逻辑卷的大小     |
| lvreduce | 减小逻辑卷的大小     |





### 章节小结

		*Linux 和 Windows 不不同之处，在于前者支持了大量不同的存储文件和目录方法。 每个文件系统方法都有不同的特性，使其适用于不同的场景。 此外，每种文件系统都使用不同的命令于存储设备打交道*
	
		*在将文件系统安装到设备之前，你得先准备好设备。 fdisk 命令用来对存储设备进行分区，以便安装文件系统。 在分区存储设备时，必须定义在上面使用什么类型的文件系统。*
	
		*划分好存储设备分区之后，你可以为该分区选用一种文件系统，不同的文件系统有不同的特性，流行的Linux 文件系统包括ext3、ext4 ，二者都提供了日志文件系统功能，降低他们在Linux系统崩溃时遇到错误或者问题的几率。*
	
		*在村塾设备分区上直接创建文件系统的一个限制因素是，如果硬盘空间用完了，你无法轻易地改变文件系统的大小。但是Linux支持逻辑卷管理，这是一种跨多个存储设备创建虚拟分区的方法。 这种方法允许你轻松地扩展一个已有文件系统，而不用完全重建。Linux LVM包提供了跨多个存储设备创建逻辑卷的命令行命令。*